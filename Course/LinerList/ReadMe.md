# 1.线性表

**文件导航**
## 1.1[线性表](SQList/SQList.c)
## 1.2[单链表](LinkNode/LinkNode.c)
### 1.2.1[无头版本](NHeadLink/NHeadLink.c)
## 1.3[双链表](DLinkNode/DLinkNode.c)
## 1.4[循环单链表](LLinkList/LLinkList.c)
## 1.5[循环双链表](LDLinkList/LDLinkList.c)

## 2.1 线性表的定义和基本操作

### 2.1.1线性表定义

线性表是具有相同**数据类型**的**n（n >= 0）**个数据元素的**有限序列**，n为表长，n=0表示一个空表。可用L命名线性表.

$$
(a_1,a_2,a_3....,a_i,...,a_n)
$$

**逻辑特性**
- 其中
  $$ a_1 $$
  是唯一的"第一个数据元素",又称表头元素.
  $$ a_n $$
  是唯一的"最后一个元素",.

- **除第一个元素外,所有元素有且只有一个直接前驱;除最后一个元素外,所有元素有且只有一个后继.**


**特点**
- 元素个数有限.(不断增长的n不是有限的).
- 表中元素具有逻辑上的顺序性,表中的元素有其先后次序.
- 表中元素都是数据元素，每个元素都是单个元素。
- 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。

### 2.1.2线性表基本操作
- InitList ( &):**初始化表**。构造一个空的线性表。（同时分配了内存空间）。
- Length (L):**求表长**。返回线性表L的长度，即L中数据元素的个数。
- LocateElem (L,e):**按值查找操作**。在表L中查找具有给定关键字值的元素。
- GetElem (L,i):**按位查找操作**。获取表L中第i个位置的元素的值。
- ListInsert (&L,i,e):**插入操作**。在表中的第i个位置上插入指定元素e。
- ListDelete(&L,i,&e):**删除操作**。删除表工中第i个位置的元素，并用e返回删除元素的值。
- PrintList(L):**输出操作**。按前后顺序输出线性表工的所有元素值。
- Empty(L):**判空操作**。若L为空表，则返回true，否则返回false。
- DestroyList(&L):**销毁操作**。销毁线性表，并释放线性表L所占用的内存空间。


## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义
线性表的顺序存储又称顺序表。它是用**一组地址连续的存储单元**依次存储线性表中的数据元素，从而使得**逻辑上相邻的两个元素在物理位置上也相邻。**第1个元素存储在线性表的起始位置,第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素a在线性表中的位序。因此，顺序表的特点是表中元素的**逻辑顺序与其物理顺序相同**。



## 2.3 线性表的链式表示

顺序表可以随时存取表中的任意一个元素，它的存储位置可以用一个简单直观的公式表但插入和删除操作需要移动大量元素。链式存储线性表时，**不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻**，它通过“链”建立起数据元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而**只需修改指针**，但也会**失去顺序表可随机存取的优点**。

### 2.3.1 单链表的定义

线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。


利用单链表可以解决顺序表**需要大量连续存储单元的缺点，**但单链表**附加指针域，也存在浪费存储空间的缺点**。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。

通常用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。**此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。**头结点的指针域指向线性表的第一个元素结点。

#### 1.有无头结点的区别

头结点和头指针的区分:不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。

**引入头结点后，可以带来两个优点:**
1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
2. 无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。


### 2.3.3 双链表

- 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和 next，分别指向其前驱结点和后继结点.


### 2.3.4 循环链表

#### 2.3.4.1 循环单链表
- 循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL,而改为指向头结点，从而整个链表形成一个环.
- 在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。

![2.线性表-2022-05-12-19-42-45](https://iceimgurl.oss-cn-beijing.aliyuncs.com/markdownimage/2.线性表-2022-05-12-19-42-45.png)


#### 2.3.4.2 循环双链表
- 头结点prior要指向表尾结点.
- 在循环双链表工中，某结点*p为尾结点时，p->next==L
- 当循环双链表为空表时，其头结点的prior域和next域都等于L

![2.线性表-2022-05-12-19-45-17](https://iceimgurl.oss-cn-beijing.aliyuncs.com/markdownimage/2.线性表-2022-05-12-19-45-17.png)


### 2.3.5 静态链表

静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标)，又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。

![2.线性表-2022-05-30-15-33-14](https://iceimgurl.oss-cn-beijing.aliyuncs.com/markdownimage/2.线性表-2022-05-30-15-33-14.png)

```C
#define MaxSize 50
typedef struct 
{
    ElemType data;
    int next;// 下一个元素的数组下标
}SLinkList[MaxSize];
```